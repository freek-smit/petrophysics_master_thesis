file_loc = 'Petrophysics.xlsx'

# KRD-01 well
MD_KRD   = pd.read_excel(file_loc, sheet_name = 'KRD_01', index_col=None, na_values=['NA'], usecols="C").to_numpy()
RHOB_KRD = pd.read_excel(file_loc, sheet_name = 'KRD_01', index_col=None, na_values=['NA'], usecols="D").to_numpy()
NPHI_KRD = pd.read_excel(file_loc, sheet_name = 'KRD_01', index_col=None, na_values=['NA'], usecols="N").to_numpy()
GR_KRD   = pd.read_excel(file_loc, sheet_name = 'KRD_01', index_col=None, na_values=['NA'], usecols="G").to_numpy()

##

" Petrophysics in KRD-01 well " 

# Depth
MD = MD_KRD[2:-1]                              # Depth column without header [m]

# Top, middle and bottom boundaries and corresponding indeces
LMU = 530                                      # Late Miocene Unconformity in well KRD-01 [m depth]
index_LMU = int(np.where(MD==LMU)[0])
MMU = 750                                      # Mid Miocene Unconformity in well KRD-01[m depth]
index_MMU = int(np.where(MD==MMU)[0])
EMU = 855                                      # Early Miocene Unconformity in well KRD-01[m depth]
index_EMU = int(np.where(MD==EMU)[0])

MD_krd = MD[index_LMU:index_EMU]

## Bulk density and Neutron porosity
start_RHOB = 2304                                   # Starting index bulk density porosity log
RHOB = RHOB_KRD[index_LMU:index_EMU]                # Bulk density     [g/cm3]
NPHI = NPHI_KRD[index_LMU:index_EMU]                # Neutron porosity [fraction]

## Calculate Density porosity (RHOP)
RHO_ma = 2.65                                       # matrix density [g/cm3], initial guess = 2.65 g/cm3
RHO_fl = 1.001                                        # !! fluid density  [g/cm3]
RHOP = (RHO_ma-RHOB)/(RHO_ma-RHO_fl)                # Density porosity over full depth interval [fraction]


## Ternary diagram calculations
x    = np.linspace(0.00,1.01,len(NPHI))        # X value for plotting
# Clean Quartz line (CQL)
QD = 2.65                                      # Quartz density [g/cm3]
CQL  = -1.65*x + QD                            # Clean quartz line
# Dry clay point line (DCPL)
point_DCPL = [0.6, 1.95]                        # Reference point DCPL
slope_DCPL = -(point_DCPL[1]-1)/(1-point_DCPL[0])   # Slope of the Dry clay point line
b = 3.38                                       # Starting point DCPL. b was guessed itteratively
DCPL = slope_DCPL*x + b                        # Dry clay point line
DCPD = 2.85                                    # Dry clay point density (should be determined from GR log) [g/cm3]
DCP  = [(DCPD-b)/slope_DCPL, DCPD]             # Dry clay point [g/cm3]
for i in range(len(DCPL)):                          
    if DCPL[i] > DCPD:                              # Loop to make DCPL stop at DCP
        DCPL[i] = "NaN"
# Dry Clay Fraction Line (DCFL)
slope_DCFL = ((DCP[1]-QD)/DCP[0])              # Slope for Dry clay fraction line
DCFL = slope_DCFL*x + 2.65                     # Dry clay fraction line
for i in range(len(DCFL)):
    if DCFL[i] > DCPD:                              # Loop to make DCFL stop at DCP
        DCFL[i] = "NaN"
# Total porosity (RHOT)
RHOT = np.zeros(len(NPHI))                     # Total porosity []
for i in range(len(NPHI)):
#    parallel_DCFL = slope_DCFL*(x-NPHI[i]) + RHOB[i]  # compute parallel lines to DCFL trough all points
    RHOT[i] = (-slope_DCFL*NPHI[i] + RHOB[i] - QD) / (-1.65 - slope_DCFL)  # Compute total porosity
    
## Wet clay point calculations
# Wet clay fraction line (WCFL)
point_WCFL = [0.5, 2.12]                       # Reference point WCFL
slope_WCFL = (QD - point_WCFL[1]) / point_WCFL[0]     # Slope for Wet Clay Fraction Line
WCFL = -slope_WCFL*x + 2.65                    # Wet Clay Fraction Line
WCPx = (2.65 - b)/(slope_WCFL + slope_DCPL)    # Calculate intersection between WCFL and DCPL
WCPD = -slope_WCFL*WCPx + 2.65                 # Calculate density of WCP
WCP = [WCPx, WCPD]                             # Wet clay point
for i in range(len(WCFL)):
    if WCFL[i] < WCPD:                              # Loop to make WCFL stop at WCP
        WCFL[i] = "NaN"
# Effective porosity (RHOE)
RHOE = np.zeros(len(NPHI))                     # Initiate effective porosity
for i in range(len(NPHI)):
#    parallel_WCFL = -slope_WCFL*(x-NPHI[i]) + RHOB[i]  # compute parallel lines to WCFL trough all points
    RHOE[i] = (slope_WCFL*NPHI[i] + RHOB[i] - QD) / (-1.65 + slope_WCFL)  # Compute Effective porosity []
    if RHOE[i] < 0:
        RHOE[i] = 0
    
## Vclay
GR = GR_KRD[2:-1]
GR = GR[index_LMU:index_EMU]
#Calculating ‘N’ and Plotting ‘N’ versus Gamma Ray
#N = (ΦNf - ΦN) / (ρb - ρfluid)                    # Plotting 'N' vs GR can aid in determining GRss and GRsh
# Vclay calculation
GRss = 22                                          # Minimum GR reading (manualy interpreted from Petrel log)
GRsh = max(GR)                                     # Maximum GR reading (manualy interpreted from Petrel log)
GRI = (GR - GRss) / (GRsh - GRss)                  # Gamma ray index
#Vcl_krd = GRI                                      # Assuming linear relationship
Vcl_krd = GRI / (3 - 2*GRI)                   # Assuming Stieber

## Clay and gas correction from Gamma ray log
# Correcting for Clay
WCP_RHOP = (RHO_ma-WCPD)/(RHO_ma-RHO_fl)           # Density porosity value wet clay point      
RHOP_cor = RHOP - Vcl_krd*(WCP_RHOP)               # Density porosity values corrected for clay volume
NPHI_cor = NPHI - Vcl_krd*(WCPx)                   # Neutron porosity values corrected for clay volume
# Gas effect --> Any corrected point above CQL is affected by gas
y_CQL = x                                          # Clean quartz line in density porosity units
for i in range(len(RHOP_cor)):
    if RHOP_cor[i] > NPHI_cor[i]:                  # Select only the points above the clean quartz line
        b2      = RHOP_cor[i] + (2/3)*NPHI_cor[i]
        gasline = -(2/3)*x + b2                    # formula for gas line. Slope is predetermined: -0.66667 (Ransom, 156)
        gas_x   =  (3/5)*b2                        # Intersection between gas line and clean quartz line
        gas_y   = gas_x                            # x intersection = y intersection because it's on the y=x CQL line
        RHOP_cor[i] = gas_y                        # Replace gas-effected RHOP points by new values
        NPHI_cor[i] = gas_x                        # Replace gas-effected NPHI points by new values

## Recalculate effective porosity
RHOB_cor = RHO_ma - RHOP_cor*(RHO_ma - RHO_fl)     # Calculate corrected values for RHOB
RHOE_cor = np.zeros(len(NPHI))                     # Initiate recalculated RHOE
for i in range(len(NPHI)):
    RHOE_cor[i] = (slope_WCFL*NPHI_cor[i] + RHOB_cor[i] - QD) / (-1.65 + slope_WCFL)  # Compute recalc. effective porosity []
    if RHOE_cor[i] < 0:
        RHOE_cor[i] = 0
    if RHOE_cor[i] > 0.48:
        RHOE_cor[i] = 0.481

phi_avg = np.mean(RHOE_cor)


## Cross plot Denisty vs Neutron porosity and Ternary diagram

# Plot Density porosity vs Neutron porosity (left y-axis)
fig1,ax = plt.subplots(1, figsize = (8,8), dpi=80)
ax.scatter(NPHI, RHOP, s = 1, color = 'red')
ax.set_xlabel('Neutron porosity []',fontsize=14)
ax.set_ylabel('Density porosity []',color="red",fontsize=14)
plt.xlim(0.0, 1.0)
ax.set_ylim(-0.3, 1.0)

# Plot Bluk density vs Neutron porosity (right y-axis)
ax2=ax.twinx()
ax2.scatter(NPHI,RHOB, s = 2, color = 'blue')
ax2.set_ylabel('Bluk density [g/cm3]',color="blue",fontsize=14)
ax2.set_ylim(1.0, 3.15)
ax2.invert_yaxis()

# Plot Ternary diagram and Total porosity
ax2.plot(x,CQL, label = 'Clean Quartz Line')
ax2.plot(x,DCPL,label = 'Dry Clay Point Line', color = 'brown')
ax2.plot(x,DCFL,label = 'Dry Clay Fraction Line')
ax2.scatter(DCP[0],DCP[1], s = 100, c = 'grey', marker = '^', label = 'Dry clay point')
ax.scatter(RHOT,RHOT, color = 'purple', s = 10)

# Plot Wet Clay Line and Effective porosity
ax2.plot(x,WCFL, label = 'Wet Clay Fraction Line')
ax.scatter(RHOE,RHOE, color = 'orange', s = 5)
ax2.scatter(WCP[0], WCP[1], s = 200, c = 'grey', marker = "*", label = 'Wet Clay Point')

# Plot clay and gas corrected points
ax.scatter(NPHI_cor,RHOP_cor, color = 'red', s = 5)

# Plotting lay-out extras and saving
#plt.title('Density Neutron cross plot, KRD-01')
ax2.legend()
ax.grid()
plt.show()
fig1.savefig('FDCCNL_KRD-01.jpg',
            format='jpeg',
            dpi=100,
            bbox_inches='tight')

## Plot porosity vs depth
fig2 = plt.figure(2, figsize = (6,10), dpi=80)
#plt.plot(RHOP, MD[index_LMU:index_EMU], label = 'Density porosity')
#plt.plot(RHOT,MD[index_LMU:index_EMU], '--', label = 'Total porosity')
plt.plot(RHOE,MD[index_LMU:index_EMU], '--', c = 'grey',label = '$\phi^e$')
plt.plot(RHOE_cor,MD[index_LMU:index_EMU], c = 'black'  ,label = '$\phi^{e,c}$')
plt.gca().invert_yaxis()
plt.ylabel('Depth [m]',fontsize=14)
plt.xlabel('Porosity [m$^3$/m$^3$]', fontsize=14)
plt.title('KRD-01   $\phi_{avg}^{e}$ = '+ str("%.2f" % phi_avg), fontsize = 14)
plt.legend(fontsize=14)
plt.grid()
plt.xlim(0,1)
plt.ylim(EMU,LMU)
plt.show()
fig2.savefig('PorDepth_KRD-01.jpg',
            format='jpeg',
            dpi=100,
            bbox_inches='tight')

## Permeability
# Kozeny-Carman
sph = 0.58                                   # Sphericity, chosen as constant from literature (Rorato et al., 2019)
i_top = np.where(LMU>M_smooth)[0][0]         # Index grain size at top 
i_bot = np.where(EMU>M_smooth)[0][0]          # Index grain size at bottom
Dpmax = xnew_M[i_top]                        # Grain size at top of this well, based on top depth (um)
Dpmin = xnew_M[i_bot]                        # Grain size at bot of this well, based on bottom depth (um)
Dp    = np.linspace(Dpmax,Dpmin,len(RHOE_cor)) # !! Grain sizes over depth interval in this well (um)
K = np.zeros(len(RHOE_cor))                     # Initiate permeability (mD)
K2 = np.zeros(len(RHOE_cor))                    # Initiate additional perm for impermeable clay situation (mD)
for i in range(len(RHOE_cor)):
    K[i] = sph**2 * (RHOE_cor[i]**3 * (Dp[i]/1e6)**2) / (150*(1-RHOE_cor[i])**2)*1.01324997e15   # !! Calculate perm trough Kozeny-Carman with Darcy (mD)
    K2[i] = sph**2 * (RHOE_cor[i]**3 * (Dp[i]/1e6)**2) / (150*(1-RHOE_cor[i])**2)*1.01324997e15
    if RHOE_cor[i] > 0.48:
        K[i] = 'nan'
        K2[i] = 'nan'
K_avg = round(np.nanmean(K))

# van Baaren equation:
C = 0.7
m = 1.4
K_vb = 10 * Dp**2 * C**(-3.64) * (m+3.64) * RHOE_cor**(m+3.64)
# Kozeny equation:
K_k = np.zeros(len(RHOE_cor))                     # !! initiate
for i in range(len(RHOE_cor)):                    # !!
    K_k[i] = 5.53 * Dpmin**2 * (RHOE_cor[i]**3 /(1-RHOE_cor[i])**2)
# Barr equation
Cs = 1
K_b = (1/(36*5*Cs) * (RHOE_cor**3 / (1-RHOE_cor)**2) * (Dp/1e6)**2) *1.01324997e15        


# Plot permeability vs depth
plt.figure(3, figsize = (6,10), dpi=80)        
plt.plot(K,MD[index_LMU:index_EMU], c = 'grey')
plt.gca().invert_yaxis()
#plt.title('Kozeny-Carman perm')
plt.title('KRD-01   $\kappa_{avg}$ = '+ str(K_avg) + ' mD', fontsize = 14)
plt.ylabel('Depth [m]',fontsize=14)
plt.xlabel('Permeability [mD]', fontsize=14)
plt.ylim(EMU,LMU)
plt.grid()
plt.show()

plt.figure(4, figsize = (6,10), dpi=80)        
plt.plot(K_vb,MD[index_LMU:index_EMU], c = 'grey')
plt.gca().invert_yaxis()
plt.title('van Baaren perm')
plt.ylabel('Depth [m]',fontsize=14)
plt.xlabel('Permeability [mD]', fontsize=14)
plt.ylim(EMU,LMU)
plt.grid()
plt.show()

plt.figure(5, figsize = (6,10), dpi=80)        
plt.plot(K_k,MD[index_LMU:index_EMU], c = 'grey')
plt.gca().invert_yaxis()
plt.title('Kozeny perm')
plt.ylabel('Depth [m]',fontsize=14)
plt.xlabel('Permeability [mD]', fontsize=14)
plt.ylim(EMU,LMU)
plt.grid()
plt.show()

plt.figure(6, figsize = (6,10), dpi=80)        
plt.plot(K_b,MD[index_LMU:index_EMU], c = 'grey')
plt.gca().invert_yaxis()
plt.title('Barr perm')
plt.ylabel('Depth [m]',fontsize=14)
plt.xlabel('Permeability [mD]', fontsize=14)
plt.ylim(EMU,LMU)
plt.grid()
plt.show()
print(np.nanmean(K),np.mean(K_vb),np.mean(K_k),np.mean(K_b))

## Net sand
MD_steps = np.zeros(len(MD_krd))
for i in range(0,len(MD_krd)-1):
    MD_steps[i] = MD_krd[i+1] - MD_krd[i]          # Make array of each depth entry and its depth increase
GRV = sum(MD_steps)                                # Safe GRV for this well. Used later for fraction

for i in range(len(MD_krd)):
    if RHOE_cor[i] < 0.15 or Vcl_krd[i] > 0.35:    # Define porosity and Vcl cutoff
        MD_steps[i] = 0                            # Apply cutoffs

MD_net = sum(MD_steps)                             # Compute net sand value
MD_netfrac = MD_net / GRV                          # Compute net sand fraction
# Print outcome
print('GRV =', "%.2f" % GRV, 'm, Net sand =', "%.2f" % MD_net, 'm, Net sand frac =', "%.2f" % MD_netfrac)
# Compute export net sand
Net_exp = MD_steps
for i in range(len(MD_steps)):
    if MD_steps[i] > 0:
        Net_exp[i] = 1                           # Create array where included cells are 1 and excluded cells 0
        
## New permeability for non reservoir rock
for i in range(len(Net_exp)):
    if Net_exp[i] == 0:
        K2[i] = 10
        

plt.figure(7, figsize = (4,6), dpi=80)
plt.scatter(Net_exp, MD_krd, c = 'grey', s = 1)
plt.gca().invert_yaxis()
plt.title('KRD-01   Net = '+ str("%.2f" % MD_netfrac), fontsize = 14)
plt.ylabel('Depth [m]', fontsize = 14)
plt.xlabel(r'$\leftarrow$ Excluded / Included $\;\rightarrow$', fontsize = 14)
plt.show()

## Export to las file
MD_final = np.zeros(len(K))
for i in range(len(K)):
    MD_final[i] = MD[index_LMU:index_EMU][i]

las = lasio.LASFile()
las.add_curve('DEPTH',MD_final, unit = 'm')
las.add_curve('Phi eff', RHOE_cor, unit = 'm3/m3', descr = 'Porosity') # !!
las.add_curve('Perm', K, unit = 'mD', descr = 'Permeability')
las.add_curve('NTG', Net_exp , unit = ' ', descr = 'NTG')
las.write('KRD_01_porperm.las', version=2) # !!
